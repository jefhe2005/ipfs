# This shell script uses nc-like executables to send and receive the file at
# $1, and prints the checksums. 3 such executables are
# github.com/h2so5/utp/ucat, invoked as h2so5-ucat, libutp-ucat, which is the
# ucat or ucat-static generated by the C++ libutp, and lastly, ./cmd/ucat from
# this repository. A good file in my experiments is no more than a few 100MB,
# or you'll be waiting a while.

set -eu
# set -x

# Passed to invocations of godo for package ./cmd/ucat.
#GODOFLAGS=-race

#export GO_UTP_PACKET_DROP=0.1
export GOPPROF=

# Invokes the implementation to test against. If there's an arg, then it's
# expected to listen.
function other_ucat() {
	if [[ $# != 0 ]]; then
		libutp-ucat -l -p 4000
		# h2so5-ucat -l :4000
	else
		libutp-ucat localhost 4000
		# h2so5-ucat localhost:4000
	fi
}

# Check what the correct result is.
md5 "$1"

rate() {
	pv -a -W -b
}

echo 'utp->other_ucat'
# Send from this uTP implementation to another client.
other_ucat -l | rate | md5 &
# sleep 1
godo ${GODOFLAGS-} ./cmd/ucat  localhost 4000 < "$1"
wait

echo 'other_ucat->utp'
# Send from the other implementation, to this one.
GO_UTP_LOGGING=0 GOPPROF= godo ${GODOFLAGS-} ./cmd/ucat -l -p 4000 | rate | md5 &
# Never receive from h2so5's ucat without a small sleep first. Don't know why.
# sleep 1
other_ucat < "$1"
wait

echo 'libutp->libutp'
libutp-ucat -l -p 4000 | rate | md5 &
libutp-ucat localhost 4000 < "$1"
wait

echo 'utp->utp'
godo ./cmd/ucat -l -p 4000 | rate | md5 &
godo ./cmd/ucat localhost 4000 < "$1"
wait

# Now check the hashes match (yes you).
